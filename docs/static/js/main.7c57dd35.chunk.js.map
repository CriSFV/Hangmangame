{"version":3,"sources":["services/api.js","components/Header.js","components/Dummy.js","components/SoluctionLetters.js","components/ErrorLetters.js","components/Form.js","components/Footer.js","components/App.js","index.js"],"names":["callToApi","fetch","then","response","json","body","Word","Header","className","Dummy","props","numberError","SolutionLetters","word","split","map","eachletter","index","userLetter","findIndex","eachletterUser","ErrorLetters","filter","letter","includes","Form","htmlFor","autoComplete","maxLength","type","name","id","value","lastLetter","onChange","ev","handlerLetter","target","Footer","App","useState","setUserLetter","setLastLetter","setWord","useEffect","regex","RegExp","match","length","ReactDOM","render","document","getElementById"],"mappings":"2SAWeA,G,YAXG,WAEhB,OAAOC,MAAM,+DACVC,MAAK,SAACC,GAAD,OAAcA,EAASC,UAC5BF,MAAK,SAACC,GAGL,OADeA,EAASE,KAAKC,U,eCEpBC,EAPA,WACb,OACE,iCACE,oBAAIC,UAAU,gBAAd,mCCiBSC,G,MAnBD,SAACC,GACb,OACE,0BAASF,UAAS,sBAAiBE,EAAMC,aAAzC,UACE,sBAAMH,UAAU,iBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,kBAChB,sBAAMA,UAAU,kBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,sBCaPI,G,KA7BS,SAACF,GAqBvB,OACE,sBAAKF,UAAU,WAAf,UACE,oBAAIA,UAAU,QAAd,0BAEA,oBAAIA,UAAU,UAAd,SAvBiBE,EAAMG,KAAKC,MAAM,IAElBC,KAAI,SAACC,EAAYC,GAMjC,OAAqB,IAJDP,EAAMQ,WAAWC,WACnC,SAACC,GAAD,OAAoBJ,IAAeI,KAKjC,oBAAIZ,UAAU,SAAd,SACGQ,GADyBC,GAKvB,oBAAIT,UAAU,UAAcS,aCG5BI,EApBM,SAACX,GAapB,OACE,sBAAKF,UAAU,WAAf,UACE,oBAAIA,UAAU,QAAd,8BACA,oBAAIA,UAAU,UAAd,SAdkBE,EAAMQ,WAAWI,QACnC,SAACC,GAAD,OAA4C,IAAhCb,EAAMG,KAAKW,SAASD,MAEfR,KAAI,SAACC,EAAYC,GAClC,OACE,oBAAIT,UAAU,SAAd,SACGQ,GADyBC,YCerBQ,EAvBF,SAACf,GAKZ,OACE,uBAAMF,UAAU,OAAhB,UACE,uBAAOA,UAAU,QAAQkB,QAAQ,cAAjC,gCAGA,uBACEC,aAAa,MACbnB,UAAU,cACVoB,UAAU,IACVC,KAAK,OACLC,KAAK,cACLC,GAAG,cACHC,MAAOtB,EAAMuB,WACbC,SAjBc,SAACC,GACnBzB,EAAM0B,cAAcD,EAAGE,OAAOL,cCyBnBM,G,MA1BA,WACb,OACE,wBAAQ9B,UAAU,SAAlB,SAoBE,uBAAOA,UAAU,eAAjB,6BCiCS+B,MA7Cf,WACE,MAAoCC,mBAAS,IAA7C,mBAAOtB,EAAP,KAAmBuB,EAAnB,KACA,EAAoCD,mBAAS,IAA7C,mBAAOP,EAAP,KAAmBS,EAAnB,KACA,EAAwBF,mBAAS,IAAjC,mBAAO3B,EAAP,KAAa8B,EAAb,KA0BA,OAvBAC,qBAAU,WACR5C,IAAYE,MAAK,SAACC,GAChBwC,EAAQxC,QAET,IAoBD,sBAAKK,UAAU,OAAf,UACE,cAAC,EAAD,IAEA,uBAAMA,UAAU,OAAhB,UACE,oCACE,cAAC,EAAD,CAAiBK,KAAMA,EAAMK,WAAYA,IACzC,cAAC,EAAD,CAAcL,KAAMA,EAAMK,WAAYA,IACtC,cAAC,EAAD,CAAMkB,cAzBQ,SAACD,GACrB,IAAIU,EAAQ,IAAIC,OAAO,cAEnBX,EAAGY,MAAMF,GACXJ,EAAc,GAAD,mBAAKvB,GAAL,CAAiBiB,KAE9BO,EAAc,KAmB0BT,WAAYA,OAElD,cAAC,EAAD,CAAOtB,YAhBSO,EAAWI,QAC7B,SAACC,GAAD,OAAsC,IAA1BV,EAAKW,SAASD,MAETyB,YAejB,cAAC,EAAD,QC7CNC,IAASC,OACP,cAAC,IAAD,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.7c57dd35.chunk.js","sourcesContent":["const callToApi = () => {\r\n  // Llamamos al API\r\n  return fetch('https://palabras-aleatorias-public-api.herokuapp.com/random')\r\n    .then((response) => response.json())\r\n    .then((response) => {\r\n      // Cuando responde el API podemos limpiar los datos aquí\r\n      const result = response.body.Word;\r\n      return result;\r\n    });\r\n};\r\n\r\nexport default callToApi;\r\n","import '../styles/Header.scss';\r\nconst Header = () => {\r\n  return (\r\n    <header>\r\n      <h1 className='header__title'>Juego del ahorcado</h1>\r\n    </header>\r\n  );\r\n};\r\nexport default Header;\r\n","import '../styles/Dummy.scss';\r\n\r\nconst Dummy = (props) => {\r\n  return (\r\n    <section className={`dummy error-${props.numberError}`}>\r\n      <span className='error-13 eye'></span>\r\n      <span className='error-12 eye'></span>\r\n      <span className='error-11 line'></span>\r\n      <span className='error-10 line'></span>\r\n      <span className='error-9 line'></span>\r\n      <span className='error-8 line'></span>\r\n      <span className='error-7 line'></span>\r\n      <span className='error-6 head'></span>\r\n      <span className='error-5 line'></span>\r\n      <span className='error-4 line'></span>\r\n      <span className='error-3 line'></span>\r\n      <span className='error-2 line'></span>\r\n      <span className='error-1 line'></span>\r\n    </section>\r\n  );\r\n};\r\nexport default Dummy;\r\n","import '../styles/Letters.scss';\r\nconst SolutionLetters = (props) => {\r\n  const renderSolutionLetter = () => {\r\n    const wordLetter = props.word.split(''); //wordLetter es el array donde se guarda la palabra en letras (convertimos la palabra en letras con el metodo split)\r\n    // cogemos el array de la palabra random y la mapeamos. cada una de la sletras la comparamos con las letras del usuario y buscamos la posición\r\n    return wordLetter.map((eachletter, index) => {\r\n      //Buscamos si coincide la letra:\r\n      const letterFound = props.userLetter.findIndex(\r\n        (eachletterUser) => eachletter === eachletterUser\r\n      );\r\n      // si coincide (porque la posición es diferente a -1, pintas la letra)\r\n      if (letterFound !== -1) {\r\n        return (\r\n          <li className='letter' key={index}>\r\n            {eachletter}\r\n          </li>\r\n        );\r\n      } else {\r\n        return <li className='letter' key={index}></li>;\r\n      }\r\n    });\r\n  };\r\n  return (\r\n    <div className='solution'>\r\n      <h2 className='title'>Solución:</h2>\r\n\r\n      <ul className='letters'>{renderSolutionLetter()}</ul>\r\n    </div>\r\n  );\r\n};\r\nexport default SolutionLetters;\r\n","import '../styles/Letters.scss';\r\nconst ErrorLetters = (props) => {\r\n  const renderErrorLetters = () => {\r\n    const errorLetter = props.userLetter.filter(\r\n      (letter) => props.word.includes(letter) === false\r\n    );\r\n    return errorLetter.map((eachletter, index) => {\r\n      return (\r\n        <li className='letter' key={index}>\r\n          {eachletter}\r\n        </li>\r\n      );\r\n    });\r\n  };\r\n  return (\r\n    <div className='feedback'>\r\n      <h2 className='title'>Letras falladas:</h2>\r\n      <ul className='letters'>{renderErrorLetters()}</ul>\r\n    </div>\r\n  );\r\n};\r\nexport default ErrorLetters;\r\n","const Form = (props) => {\r\n  const hadleChange = (ev) => {\r\n    props.handlerLetter(ev.target.value);\r\n  };\r\n\r\n  return (\r\n    <form className='form'>\r\n      <label className='title' htmlFor='last-letter'>\r\n        Escribe una letra:\r\n      </label>\r\n      <input\r\n        autoComplete='off'\r\n        className='form__input'\r\n        maxLength='1'\r\n        type='text'\r\n        name='last-letter'\r\n        id='last-letter'\r\n        value={props.lastLetter}\r\n        onChange={hadleChange}\r\n      />\r\n    </form>\r\n  );\r\n};\r\nexport default Form;\r\n","import '../styles/Footer.scss';\r\nconst Footer = () => {\r\n  return (\r\n    <footer className='footer'>\r\n      {/* <nav>\r\n        <ul className='footer__menu'>\r\n          <li className='footer__menu-item'>\r\n            <a className='footer__menu-link' href='#/'>\r\n              A jugar\r\n            </a>\r\n          </li>\r\n          <li className='footer__menu-item'>\r\n            <a className='footer__menu-link active' href='#/instructions'>\r\n              ¿Cómo se juega?\r\n            </a>\r\n          </li>\r\n          <li className='footer__menu-item'>\r\n            <a className='footer__menu-link' href='#/options'>\r\n              Más opciones\r\n            </a>\r\n          </li>\r\n        </ul>\r\n      </nav> */}\r\n      <small className='footer__copy'>© Adalab</small>\r\n    </footer>\r\n  );\r\n};\r\nexport default Footer;\r\n","import '../styles/App.scss';\nimport '../styles/Form.scss';\nimport { useState, useEffect } from 'react';\nimport callToApi from '../services/api';\nimport Header from './Header';\nimport Dummy from './Dummy';\nimport SolutionLetters from './SoluctionLetters';\nimport ErrorLetters from './ErrorLetters';\nimport Form from './Form';\nimport Footer from './Footer';\n\nfunction App() {\n  const [userLetter, setUserLetter] = useState([]); //donde se almacena las letras de la jugadora (todas)\n  const [lastLetter, setLastLetter] = useState(''); //string para almacenar al última letra introducida por la jugadora (si no es permitida no se incluye, por eso no lo pinta aunque marques tecla)\n  const [word, setWord] = useState(''); //donde) se va a almacenar la palabra a adivinar\n\n  //petición random word:\n  useEffect(() => {\n    callToApi().then((response) => {\n      setWord(response);\n    });\n  }, []);\n\n  const handlerLetter = (ev) => {\n    let regex = new RegExp('^[a-zA-Z]$'); // letras permitidas, el resto no lo están\n    // si la letra esta permitida:\n    if (ev.match(regex)) {\n      setUserLetter([...userLetter, ev]);\n    } else {\n      setLastLetter(''); //si es número no pinta nada porque aquí le estamos diciendo que sea string vacío y tampoco se guarda en el estado\n    }\n  };\n\n  const numberError = () => {\n    const errorLetter = userLetter.filter(\n      (letter) => word.includes(letter) === false\n    );\n    return errorLetter.length;\n  };\n\n  return (\n    <div className='page'>\n      <Header />\n\n      <main className='main'>\n        <section>\n          <SolutionLetters word={word} userLetter={userLetter} />\n          <ErrorLetters word={word} userLetter={userLetter} />\n          <Form handlerLetter={handlerLetter} lastLetter={lastLetter} />\n        </section>\n        <Dummy numberError={numberError()} />\n      </main>\n      <Footer />\n    </div>\n  );\n}\nexport default App;\n","// Fichero src/index.js (código nuevo)\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { HashRouter } from 'react-router-dom';\nimport App from './components/App';\n\nReactDOM.render(\n  <HashRouter>\n    <App />\n  </HashRouter>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}