{"version":3,"sources":["services/api.js","components/Header.js","components/Footer.js","components/Dummy.js","components/SoluctionLetters.js","components/ErrorLetters.js","components/Form.js","components/Main.js","components/Instructions.js","components/App.js","index.js"],"names":["callToApi","fetch","then","response","json","body","Word","Header","className","Footer","href","Dummy","props","numberError","SolutionLetters","word","split","map","eachletter","index","userLetter","findIndex","eachletterUser","ErrorLetters","filter","letter","includes","Form","htmlFor","autoComplete","maxLength","type","name","id","value","lastLetter","onChange","ev","handlerLetter","target","Main","Instructions","App","useState","setUserLetter","setLastLetter","setWord","useEffect","path","element","regex","RegExp","match","length","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.145d26e8.chunk.js","sourcesContent":["const callToApi = () => {\r\n  // Llamamos al API\r\n  return fetch('https://palabras-aleatorias-public-api.herokuapp.com/random')\r\n    .then((response) => response.json())\r\n    .then((response) => {\r\n      // Cuando responde el API podemos limpiar los datos aquí\r\n      const result = response.body.Word;\r\n      return result;\r\n    });\r\n};\r\n\r\nexport default callToApi;\r\n","import '../styles/Header.scss';\r\nconst Header = () => {\r\n  return (\r\n    <header>\r\n      <h1 className='header__title'>Juego del ahorcado</h1>\r\n    </header>\r\n  );\r\n};\r\nexport default Header;\r\n","import '../styles/Footer.scss';\r\n\r\nconst Footer = () => {\r\n  return (\r\n    <footer className='footer'>\r\n      <nav>\r\n        <ul className='footer__menu'>\r\n          <li className='footer__menu-item'>\r\n            <a className='footer__menu-link' href='/'>\r\n              A jugar\r\n            </a>\r\n          </li>\r\n\r\n          <li className='footer__menu-item'>\r\n            <a className='footer__menu-link active' href='/instructions'>\r\n              ¿Cómo se juega?\r\n            </a>\r\n          </li>\r\n\r\n          {/* <li className='footer__menu-item'>\r\n            <a className='footer__menu-link' href='/options'>\r\n              Más opciones\r\n            </a>\r\n          </li> */}\r\n        </ul>\r\n      </nav>\r\n      <small className='footer__copy'>© Adalab</small>\r\n    </footer>\r\n  );\r\n};\r\nexport default Footer;\r\n","import '../styles/Dummy.scss';\r\n\r\nconst Dummy = (props) => {\r\n  return (\r\n    <section className={`dummy error-${props.numberError}`}>\r\n      <span className='error-13 eye'></span>\r\n      <span className='error-12 eye'></span>\r\n      <span className='error-11 line'></span>\r\n      <span className='error-10 line'></span>\r\n      <span className='error-9 line'></span>\r\n      <span className='error-8 line'></span>\r\n      <span className='error-7 line'></span>\r\n      <span className='error-6 head'></span>\r\n      <span className='error-5 line'></span>\r\n      <span className='error-4 line'></span>\r\n      <span className='error-3 line'></span>\r\n      <span className='error-2 line'></span>\r\n      <span className='error-1 line'></span>\r\n    </section>\r\n  );\r\n};\r\nexport default Dummy;\r\n","import '../styles/Letters.scss';\r\nconst SolutionLetters = (props) => {\r\n  const renderSolutionLetter = () => {\r\n    const wordLetter = props.word.split(''); //wordLetter es el array donde se guarda la palabra en letras (convertimos la palabra en letras con el metodo split)\r\n    // cogemos el array de la palabra random y la mapeamos. cada una de la sletras la comparamos con las letras del usuario y buscamos la posición\r\n    return wordLetter.map((eachletter, index) => {\r\n      //Buscamos si coincide la letra:\r\n      const letterFound = props.userLetter.findIndex(\r\n        (eachletterUser) => eachletter === eachletterUser\r\n      );\r\n      // si coincide (porque la posición es diferente a -1, pintas la letra)\r\n      if (letterFound !== -1) {\r\n        return (\r\n          <li className='letter' key={index}>\r\n            {eachletter}\r\n          </li>\r\n        );\r\n      } else {\r\n        return <li className='letter' key={index}></li>;\r\n      }\r\n    });\r\n  };\r\n  return (\r\n    <div className='solution'>\r\n      <h2 className='title'>Solución:</h2>\r\n\r\n      <ul className='letters'>{renderSolutionLetter()}</ul>\r\n    </div>\r\n  );\r\n};\r\nexport default SolutionLetters;\r\n","import '../styles/Letters.scss';\r\nconst ErrorLetters = (props) => {\r\n  const renderErrorLetters = () => {\r\n    const errorLetter = props.userLetter.filter(\r\n      (letter) => props.word.includes(letter) === false\r\n    );\r\n    return errorLetter.map((eachletter, index) => {\r\n      return (\r\n        <li className='letter' key={index}>\r\n          {eachletter}\r\n        </li>\r\n      );\r\n    });\r\n  };\r\n  return (\r\n    <div className='feedback'>\r\n      <h2 className='title'>Letras falladas:</h2>\r\n      <ul className='letters'>{renderErrorLetters()}</ul>\r\n    </div>\r\n  );\r\n};\r\nexport default ErrorLetters;\r\n","const Form = (props) => {\r\n  const hadleChange = (ev) => {\r\n    props.handlerLetter(ev.target.value);\r\n  };\r\n\r\n  return (\r\n    <form className='form'>\r\n      <label className='title' htmlFor='last-letter'>\r\n        Escribe una letra:\r\n      </label>\r\n      <input\r\n        autoComplete='off'\r\n        className='form__input'\r\n        maxLength='1'\r\n        type='text'\r\n        name='last-letter'\r\n        id='last-letter'\r\n        value={props.lastLetter}\r\n        onChange={hadleChange}\r\n      />\r\n    </form>\r\n  );\r\n};\r\nexport default Form;\r\n","import Dummy from './Dummy';\r\nimport SolutionLetters from './SoluctionLetters';\r\nimport ErrorLetters from './ErrorLetters';\r\nimport Form from './Form';\r\nexport const Main = (props) => {\r\n  return (\r\n    <main className='main'>\r\n      <section>\r\n        <SolutionLetters word={props.word} userLetter={props.userLetter} />\r\n        <ErrorLetters word={props.word} userLetter={props.userLetter} />\r\n        <Form\r\n          handlerLetter={props.handlerLetter}\r\n          lastLetter={props.lastLetter}\r\n        />\r\n      </section>\r\n      <Dummy numberError={props.numberError()} />\r\n    </main>\r\n  );\r\n};\r\n","import '../styles/Instructions.scss';\r\n\r\nconst Instructions = () => {\r\n  return (\r\n    <section className='instructions'>\r\n      <p>\r\n        Haz click donde indica \"Escribe una letra\" y escribe tu letra para\r\n        adivinar la palabra secreta aleatoria. Si fallas la letra te indicará si\r\n        has acertado, ya que se escribirá en su posición correspondiente de la\r\n        solución y si no, se añadirá a las letras falladas. Ten cuidado o lo\r\n        ahorcarás.\r\n      </p>\r\n      <p>¡A jugar!</p>\r\n    </section>\r\n  );\r\n};\r\nexport default Instructions;\r\n","import '../styles/App.scss';\nimport '../styles/Form.scss';\nimport { useState, useEffect } from 'react';\nimport callToApi from '../services/api';\nimport Header from './Header';\n\nimport Footer from './Footer';\nimport { Main } from './Main';\nimport { Route, Routes } from 'react-router-dom';\nimport Instructions from './Instructions';\n\nfunction App() {\n  const [userLetter, setUserLetter] = useState([]); //donde se almacena las letras de la jugadora (todas)\n  const [lastLetter, setLastLetter] = useState(''); //string para almacenar al última letra introducida por la jugadora (si no es permitida no se incluye, por eso no lo pinta aunque marques tecla)\n  const [word, setWord] = useState(''); //donde) se va a almacenar la palabra a adivinar\n\n  //petición random word:\n  useEffect(() => {\n    callToApi().then((response) => {\n      setWord(response);\n    });\n  }, []);\n\n  const handlerLetter = (ev) => {\n    let regex = new RegExp('^[a-zA-Z]$'); // letras permitidas, el resto no lo están\n    // si la letra esta permitida:\n    if (ev.match(regex)) {\n      setUserLetter([...userLetter, ev]);\n    } else {\n      setLastLetter(''); //si es número no pinta nada porque aquí le estamos diciendo que sea string vacío y tampoco se guarda en el estado\n    }\n  };\n\n  const numberError = () => {\n    const errorLetter = userLetter.filter(\n      (letter) => word.includes(letter) === false\n    );\n    return errorLetter.length;\n  };\n\n  return (\n    <div className='page'>\n      <Header />\n      <Routes>\n        <Route\n          path='/'\n          element={\n            <Main\n              word={word}\n              userLetter={userLetter}\n              handlerLetter={handlerLetter}\n              lastLetter={lastLetter}\n              numberError={numberError}\n            />\n          }\n        />\n        <Route path='/instructions' element={<Instructions />} />\n      </Routes>\n\n      <Footer />\n    </div>\n  );\n}\nexport default App;\n","// Fichero src/index.js (código nuevo)\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { BrowserRouter } from 'react-router-dom';\n//import { HashRouter } from 'react-router-dom';\nimport App from './components/App';\n\nReactDOM.render(\n  <BrowserRouter>\n    <App />\n  </BrowserRouter>,\n\n  document.getElementById('root')\n);\n"],"sourceRoot":""}