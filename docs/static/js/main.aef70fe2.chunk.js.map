{"version":3,"sources":["services/api.js","components/Header.js","components/Footer.js","components/Dummy.js","components/SoluctionLetters.js","components/ErrorLetters.js","components/Form.js","components/Main.js","components/Instructions.js","components/Options.js","components/App.js","index.js"],"names":["callToApi","fetch","then","response","json","body","Word","Header","className","Footer","navData","isActive","to","Dummy","props","numberError","SolutionLetters","word","split","map","eachletter","index","userLetter","findIndex","eachletterUser","ErrorLetters","filter","letter","includes","Form","htmlFor","autoComplete","maxLength","type","name","id","value","lastLetter","onChange","ev","handlerLetter","target","Main","Instructions","Options","App","useState","setUserLetter","setLastLetter","setWord","useEffect","path","element","regex","RegExp","match","length","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.aef70fe2.chunk.js","sourcesContent":["const callToApi = () => {\r\n  // Llamamos al API\r\n  return fetch('https://palabras-aleatorias-public-api.herokuapp.com/random')\r\n    .then((response) => response.json())\r\n    .then((response) => {\r\n      // Cuando responde el API podemos limpiar los datos aquí\r\n      const result = response.body.Word;\r\n      return result;\r\n    });\r\n};\r\n\r\nexport default callToApi;\r\n","import '../styles/Header.scss';\r\nconst Header = () => {\r\n  return (\r\n    <header>\r\n      <h1 className='header__title'>Juego del ahorcado</h1>\r\n    </header>\r\n  );\r\n};\r\nexport default Header;\r\n","import { NavLink } from 'react-router-dom';\r\nimport '../styles/Footer.scss';\r\n\r\nconst Footer = () => {\r\n  return (\r\n    <footer className='footer'>\r\n      <nav>\r\n        <ul className='footer__menu'>\r\n          <li className='footer__menu-item'>\r\n            <NavLink\r\n              className={(navData) => {\r\n                return navData.isActive\r\n                  ? 'footer__menu-link active'\r\n                  : 'footer__menu-link ';\r\n              }}\r\n              to='/'\r\n            >\r\n              A jugar\r\n            </NavLink>\r\n          </li>\r\n\r\n          <li className='footer__menu-item'>\r\n            <NavLink\r\n              className={(navData) => {\r\n                return navData.isActive\r\n                  ? 'footer__menu-link active'\r\n                  : 'footer__menu-link ';\r\n              }}\r\n              to='/instructions'\r\n            >\r\n              ¿Cómo se juega?\r\n            </NavLink>\r\n          </li>\r\n\r\n          <li className='footer__menu-item'>\r\n            <NavLink\r\n              className={(navData) => {\r\n                return navData.isActive\r\n                  ? 'footer__menu-link active'\r\n                  : 'footer__menu-link ';\r\n              }}\r\n              to='/options'\r\n            >\r\n              Mas opciones\r\n            </NavLink>\r\n          </li>\r\n        </ul>\r\n      </nav>\r\n      <small className='footer__copy'>© Adalab</small>\r\n    </footer>\r\n  );\r\n};\r\nexport default Footer;\r\n","import '../styles/Dummy.scss';\r\n\r\nconst Dummy = (props) => {\r\n  return (\r\n    <section className={`dummy error-${props.numberError}`}>\r\n      <span className='error-13 eye'></span>\r\n      <span className='error-12 eye'></span>\r\n      <span className='error-11 line'></span>\r\n      <span className='error-10 line'></span>\r\n      <span className='error-9 line'></span>\r\n      <span className='error-8 line'></span>\r\n      <span className='error-7 line'></span>\r\n      <span className='error-6 head'></span>\r\n      <span className='error-5 line'></span>\r\n      <span className='error-4 line'></span>\r\n      <span className='error-3 line'></span>\r\n      <span className='error-2 line'></span>\r\n      <span className='error-1 line'></span>\r\n    </section>\r\n  );\r\n};\r\nexport default Dummy;\r\n","import '../styles/Letters.scss';\r\nconst SolutionLetters = (props) => {\r\n  const renderSolutionLetter = () => {\r\n    const wordLetter = props.word.split(''); //wordLetter es el array donde se guarda la palabra en letras (convertimos la palabra en letras con el metodo split)\r\n    // cogemos el array de la palabra random y la mapeamos. cada una de la sletras la comparamos con las letras del usuario y buscamos la posición\r\n    return wordLetter.map((eachletter, index) => {\r\n      //Buscamos si coincide la letra:\r\n      const letterFound = props.userLetter.findIndex(\r\n        (eachletterUser) => eachletter === eachletterUser\r\n      );\r\n      // si coincide (porque la posición es diferente a -1, pintas la letra)\r\n      if (letterFound !== -1) {\r\n        return (\r\n          <li className='letter' key={index}>\r\n            {eachletter}\r\n          </li>\r\n        );\r\n      } else {\r\n        return <li className='letter' key={index}></li>;\r\n      }\r\n    });\r\n  };\r\n  return (\r\n    <div className='solution'>\r\n      <h2 className='title'>Solución:</h2>\r\n\r\n      <ul className='letters'>{renderSolutionLetter()}</ul>\r\n    </div>\r\n  );\r\n};\r\nexport default SolutionLetters;\r\n","import '../styles/Letters.scss';\r\nconst ErrorLetters = (props) => {\r\n  const renderErrorLetters = () => {\r\n    const errorLetter = props.userLetter.filter(\r\n      (letter) => props.word.includes(letter) === false\r\n    );\r\n    return errorLetter.map((eachletter, index) => {\r\n      return (\r\n        <li className='letter' key={index}>\r\n          {eachletter}\r\n        </li>\r\n      );\r\n    });\r\n  };\r\n  return (\r\n    <div className='feedback'>\r\n      <h2 className='title'>Letras falladas:</h2>\r\n      <ul className='letters'>{renderErrorLetters()}</ul>\r\n    </div>\r\n  );\r\n};\r\nexport default ErrorLetters;\r\n","const Form = (props) => {\r\n  const hadleChange = (ev) => {\r\n    props.handlerLetter(ev.target.value);\r\n  };\r\n\r\n  return (\r\n    <form className='form'>\r\n      <label className='title' htmlFor='last-letter'>\r\n        Escribe una letra:\r\n      </label>\r\n      <input\r\n        autoComplete='off'\r\n        className='form__input'\r\n        maxLength='1'\r\n        type='text'\r\n        name='last-letter'\r\n        id='last-letter'\r\n        value={props.lastLetter}\r\n        onChange={hadleChange}\r\n      />\r\n    </form>\r\n  );\r\n};\r\nexport default Form;\r\n","import Dummy from './Dummy';\r\nimport SolutionLetters from './SoluctionLetters';\r\nimport ErrorLetters from './ErrorLetters';\r\nimport Form from './Form';\r\n\r\nexport const Main = (props) => {\r\n  return (\r\n    <main className='main'>\r\n      <section>\r\n        <SolutionLetters word={props.word} userLetter={props.userLetter} />\r\n        <ErrorLetters word={props.word} userLetter={props.userLetter} />\r\n        <Form\r\n          handlerLetter={props.handlerLetter}\r\n          lastLetter={props.lastLetter}\r\n        />\r\n      </section>\r\n      <Dummy numberError={props.numberError()} />\r\n    </main>\r\n  );\r\n};\r\n","import '../styles/Instructions.scss';\r\n\r\nconst Instructions = () => {\r\n  return (\r\n    <section className='instructions'>\r\n      <p>\r\n        Haz click donde indica \"Escribe una letra\" y escribe tu letra para\r\n        adivinar la palabra secreta aleatoria. Si fallas la letra te indicará si\r\n        has acertado, ya que se escribirá en su posición correspondiente de la\r\n        solución y si no, se añadirá a las letras falladas. Ten cuidado o lo\r\n        ahorcarás.\r\n      </p>\r\n      <p>¡A jugar!</p>\r\n    </section>\r\n  );\r\n};\r\nexport default Instructions;\r\n","import '../styles/Options.scss';\r\nimport { NavLink } from 'react-router-dom';\r\n\r\nexport const Options = () => {\r\n  return (\r\n    <>\r\n      <form className='user__form'>\r\n        <label className='title' htmlFor='user__word'>\r\n          Incluye la palabra con la que quieres jugar:\r\n        </label>\r\n        <input\r\n          autoComplete='off'\r\n          className='user__form__input'\r\n          type='text'\r\n          name='user__word'\r\n          id='user__word'\r\n        />\r\n        <NavLink to='/userGame' className='user__button'>\r\n          Jugar\r\n        </NavLink>\r\n        <small className='underconstruction'>\r\n          *Esta opción aún no está desarrollada completamente\r\n        </small>\r\n      </form>\r\n    </>\r\n  );\r\n};\r\n","import '../styles/App.scss';\nimport '../styles/Form.scss';\nimport { useState, useEffect } from 'react';\nimport callToApi from '../services/api';\nimport Header from './Header';\n\nimport Footer from './Footer';\nimport { Main } from './Main';\nimport { Route, Routes } from 'react-router-dom';\nimport Instructions from './Instructions';\nimport { Options } from './Options';\n\nfunction App() {\n  const [userLetter, setUserLetter] = useState([]); //donde se almacena las letras de la jugadora (todas)\n  const [lastLetter, setLastLetter] = useState(''); //string para almacenar al última letra introducida por la jugadora (si no es permitida no se incluye, por eso no lo pinta aunque marques tecla)\n  const [word, setWord] = useState(''); //donde) se va a almacenar la palabra a adivinar\n\n  //petición random word:\n  useEffect(() => {\n    callToApi().then((response) => {\n      setWord(response);\n    });\n  }, []);\n\n  const handlerLetter = (ev) => {\n    let regex = new RegExp('^[a-zA-Z]$'); // letras permitidas, el resto no lo están\n    // si la letra esta permitida:\n    if (ev.match(regex)) {\n      setUserLetter([...userLetter, ev]);\n    } else {\n      setLastLetter(''); //si es número no pinta nada porque aquí le estamos diciendo que sea string vacío y tampoco se guarda en el estado\n    }\n  };\n\n  const numberError = () => {\n    const errorLetter = userLetter.filter(\n      (letter) => word.includes(letter) === false\n    );\n    return errorLetter.length;\n  };\n\n  return (\n    <div className='page'>\n      <Header />\n      <Routes>\n        <Route\n          path='/'\n          element={\n            <Main\n              word={word}\n              userLetter={userLetter}\n              handlerLetter={handlerLetter}\n              lastLetter={lastLetter}\n              numberError={numberError}\n            />\n          }\n        />\n        <Route path='/instructions' element={<Instructions />} />\n        <Route path='/options' element={<Options />} />\n      </Routes>\n\n      <Footer />\n    </div>\n  );\n}\nexport default App;\n","// Fichero src/index.js (código nuevo)\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n//import { BrowserRouter } from 'react-router-dom';\nimport { HashRouter } from 'react-router-dom';\nimport App from './components/App';\n\nReactDOM.render(\n  <HashRouter>\n    <App />\n  </HashRouter>,\n\n  document.getElementById('root')\n);\n"],"sourceRoot":""}